---
- name: Crear VM Rocky Linux 9.6 en Hyper-V (ISO Rocky + Kickstart OEMDRV)
  hosts: "{{ hyperv_host }}"
  gather_facts: no

  collections:
    - ansible.windows

  vars:
    # Hosts Hyper-V permitidos (nombres como en tu inventario)
    hyperv_hosts:
      - SMXHVCEDIS
      - SMXHVFCAWS19
      - SMXHVFCBWS19
      - SMXFCHVB
      - SMXHYPVA

    # vSwitch por defecto
    default_switch: 'LAN-Prod'

    # Unidades donde se pueden guardar discos de la VM
    candidate_drives:
      - 'D'
      - 'E'

    # ISO Rocky por defecto en NAS
    iso_path_default: '\\10.138.120.130\isos\Rocky-9.6-x86_64-dvd.iso'

    # NAS para el SMB Global Mapping
    nas_server: '10.138.120.130'
    nas_share: 'isos'
    nas_user: 'NASUSER_AQUI'
    nas_pass: 'NASPASS_AQUI'

    # Ruta local de oscdimg.exe en el host Hyper-V
    oscdimg_path: 'C:\\Oscdimg\\oscdimg.exe'

    # Parámetros de la instalación de Rocky
    root_password: "Passw0rd."
    linux_user: "adm"
    linux_password: "Passw0rd."
    timezone: "America/Mexico_City"
    lang: "es_MX.UTF-8"

  tasks:
    # -------------------------------------------------------------------
    # 0) Validaciones y normalización
    # -------------------------------------------------------------------
    - name: Validar host Hyper-V permitido
      ansible.builtin.assert:
        that:
          - inventory_hostname in hyperv_hosts
        fail_msg: "El host {{ inventory_hostname }} no está en la lista de hyperv_hosts permitidos."

    - name: Validar variables obligatorias
      ansible.builtin.assert:
        that:
          - vm_name is defined
          - memory_gb is defined
          - cpu is defined
          - disk_gb is defined
          - vm_ip is defined
          - vm_mask is defined
          - vm_gateway is defined
          - vm_dns1 is defined
        fail_msg: >-
          Faltan variables: vm_name, memory_gb, cpu, disk_gb,
          vm_ip, vm_mask, vm_gateway, vm_dns1.

    - name: Normalizar variables numéricas y rutas
      ansible.builtin.set_fact:
        v_switch_eff: "{{ v_switch | default(default_switch) }}"
        iso_path_eff: "{{ iso_path | default(iso_path_default) }}"
        memory_bytes: "{{ (memory_gb | int) * 1073741824 }}"
        disk_bytes: "{{ (disk_gb | int) * 1073741824 }}"
        cpu_count: "{{ cpu | int }}"
        vm_dns2_eff: "{{ vm_dns2 | default(vm_dns1) }}"
        ks_dir: "C:\\kickstart\\{{ vm_name }}"
        ks_cfg_path: "C:\\kickstart\\{{ vm_name }}\\ks.cfg"
        ks_iso_path: "C:\\ISOs\\{{ vm_name }}_ks.iso"

    # -------------------------------------------------------------------
    # 1) SMB Global Mapping hacia la NAS
    # -------------------------------------------------------------------
    - name: Verificar si SMB Global Mapping ya existe
      ansible.windows.win_shell: |
        $remotePath = "\\{{ nas_server }}\{{ nas_share }}"
        $mapping = Get-SmbGlobalMapping -RemotePath $remotePath -ErrorAction SilentlyContinue
        if ($mapping) {
          Write-Output "EXISTS"
        } else {
          Write-Output "NOTFOUND"
        }
      register: smb_check
      changed_when: false

    - name: Crear SMB Global Mapping hacia la NAS para Hyper-V
      ansible.windows.win_shell: |
        $remotePath = "\\{{ nas_server }}\{{ nas_share }}"
        $secPass = ConvertTo-SecureString "{{ nas_pass }}" -AsPlainText -Force
        $cred = New-Object System.Management.Automation.PSCredential("{{ nas_user }}", $secPass)
        
        # Intentar limpiar mapeos previos
        try { 
          net use $remotePath /delete /y 2>$null 
        } catch { }
        
        # Crear el mapping
        New-SmbGlobalMapping -RemotePath $remotePath -Credential $cred -Persistent $true -ErrorAction Stop
        Write-Output "Mapping creado exitosamente"
      when: smb_check.stdout.strip() == "NOTFOUND"
      register: smb_result

    # -------------------------------------------------------------------
    # 2) Preparar carpetas (ISOs y Kickstart)
    # -------------------------------------------------------------------
    - name: Crear carpeta local para ISOs
      ansible.windows.win_file:
        path: "C:\\ISOs"
        state: directory

    - name: Crear carpeta Kickstart para esta VM
      ansible.windows.win_file:
        path: "{{ ks_dir }}"
        state: directory

    # ✅ CORREGIDO: Usar win_template en lugar de ansible.builtin.template
    - name: Generar ks.cfg (Kickstart) para Rocky Linux 9.6
      ansible.windows.win_template:
        src: "templates/ks.cfg.j2"
        dest: "{{ ks_cfg_path }}"

    # -------------------------------------------------------------------
    # 3) Crear ISO OEMDRV con ks.cfg usando oscdimg
    # -------------------------------------------------------------------
    - name: Verificar existencia de oscdimg.exe
      ansible.windows.win_stat:
        path: "{{ oscdimg_path }}"
      register: oscdimg_stat

    - name: Fallar si oscdimg no existe
      ansible.builtin.fail:
        msg: "oscdimg.exe no encontrado en {{ oscdimg_path }}"
      when: not oscdimg_stat.stat.exists

    - name: Eliminar ISO Kickstart anterior si existe
      ansible.windows.win_file:
        path: "{{ ks_iso_path }}"
        state: absent

    - name: Crear ISO Kickstart (OEMDRV) con oscdimg
      ansible.windows.win_command: >
        "{{ oscdimg_path }}"
        -lOEMDRV
        -n
        -m
        "{{ ks_dir }}"
        "{{ ks_iso_path }}"
      args:
        creates: "{{ ks_iso_path }}"
      register: oscdimg_result

    # -------------------------------------------------------------------
    # 4) Crear / ajustar VM, VHD, DVDs y firmware
    # -------------------------------------------------------------------
    - name: Crear VM Rocky Linux 9.6 en Hyper-V con ISO en NAS + ISO Kickstart
      ansible.windows.win_powershell:
        script: |
          param(
            [string]$VmName,
            [Int64]$MemoryBytes,
            [Int64]$DiskBytes,
            [int]$CpuCount,
            [string]$SwitchName,
            [string]$IsoPath,
            [string]$KsIsoPath,
            [string[]]$CandidateDrives,
            [int]$VlanId = 0
          )

          Import-Module Hyper-V

          # 1. Elegir unidad con más espacio (D/E)
          $drives = foreach ($d in $CandidateDrives) {
            try { Get-PSDrive -Name $d -ErrorAction Stop } catch { $null }
          }
          if (-not $drives) {
            throw "Ninguna de las unidades candidatas ($($CandidateDrives -join ', ')) existe en este host."
          }
          $bestDrive = $drives | Sort-Object Free -Descending | Select-Object -First 1
          Write-Host "Usando unidad $($bestDrive.Name): $([math]::Round($bestDrive.Free/1GB,2)) GB libres"

          $root          = $bestDrive.Root
          $clusterRoot   = "$root\$VmName"
          $snapshotsRoot = Join-Path $clusterRoot "Snapshots"
          $vhdRoot       = Join-Path $clusterRoot "Virtual Hard Disks"

          foreach ($p in @($clusterRoot, $snapshotsRoot, $vhdRoot)) {
            if (-not (Test-Path $p)) {
              New-Item -ItemType Directory -Path $p -Force | Out-Null
            }
          }

          $VmPath  = $root
          $VhdPath = Join-Path $vhdRoot "$VmName.vhdx"

          # 2. Validar ISOs
          if (-not (Test-Path $IsoPath)) {
            throw "No se puede acceder a la ISO de Rocky: $IsoPath"
          }
          if (-not (Test-Path $KsIsoPath)) {
            throw "No se puede acceder a la ISO Kickstart (OEMDRV): $KsIsoPath"
          }

          # 3. Crear VHDX si no existe
          if (-not (Test-Path $VhdPath)) {
            New-VHD -Path $VhdPath -SizeBytes $DiskBytes -Dynamic | Out-Null
            Write-Host "VHD creado: $VhdPath"
          } else {
            Write-Host "VHD ya existía: $VhdPath"
          }

          # 4. Crear VM SIN VHD (NoVHD) para controlar puertos
          $vm = Get-VM -Name $VmName -ErrorAction SilentlyContinue
          if (-not $vm) {
            New-VM -Name $VmName `
                   -MemoryStartupBytes $MemoryBytes `
                   -Generation 2 `
                   -SwitchName $SwitchName `
                   -Path $VmPath `
                   -NoVHD | Out-Null
            $vm = Get-VM -Name $VmName
            Write-Host "VM creada: $VmName"
          } else {
            Write-Host "VM ya existía: $VmName"
          }

          # 4.1 VLAN (si se envía vm_vlan)
          if ($VlanId -gt 0) {
            Write-Host "Se solicitó VLAN $VlanId. Buscando adaptador de red de la VM $VmName..."

            $nic = $null
            for ($i = 1; $i -le 10; $i++) {
              $nic = Get-VMNetworkAdapter -VMName $VmName -ErrorAction SilentlyContinue
              if ($nic) { break }
              Start-Sleep -Seconds 1
            }

            if (-not $nic) {
              throw "No se encontró adaptador de red en la VM $VmName después de esperar."
            }

            Write-Host "Adaptador encontrado: $($nic.Name). Aplicando VLAN $VlanId."
            Set-VMNetworkAdapterVlan `
              -VMName $VmName `
              -VMNetworkAdapterName $nic.Name `
              -Access `
              -VlanId $VlanId `
              -ErrorAction Stop

            Write-Host "VLAN $VlanId aplicada correctamente."
          } else {
            Write-Host "Sin vm_vlan, se deja la VM untagged."
            Set-VMNetworkAdapterVlan -VMName $VmName -Untagged -ErrorAction SilentlyContinue
          }

          # 5. Asegurar VHD en SCSI 0:2
          $osDisk = Get-VMHardDiskDrive -VMName $VmName -ErrorAction SilentlyContinue |
                    Where-Object { $_.Path -eq $VhdPath }

          if ($osDisk) {
            if ($osDisk.ControllerNumber -ne 0 -or $osDisk.ControllerLocation -ne 2) {
              Remove-VMHardDiskDrive -VMName $VmName `
                                     -ControllerNumber $osDisk.ControllerNumber `
                                     -ControllerLocation $osDisk.ControllerLocation
              Add-VMHardDiskDrive -VMName $VmName `
                                   -ControllerNumber 0 `
                                   -ControllerLocation 2 `
                                   -Path $VhdPath | Out-Null
            }
          } else {
            Add-VMHardDiskDrive -VMName $VmName `
                                 -ControllerNumber 0 `
                                 -ControllerLocation 2 `
                                 -Path $VhdPath | Out-Null
          }

          # 6. CPU y memoria estática
          Set-VMProcessor -VMName $VmName -Count $CpuCount
          Set-VMMemory -VMName $VmName `
            -DynamicMemoryEnabled $false `
            -StartupBytes $MemoryBytes

          # 7. Apagar VM antes de tocar firmware/DVD
          $vm = Get-VM -Name $VmName
          if ($vm.State -ne 'Off') {
            Stop-VM -Name $VmName -TurnOff -Force
            do {
              Start-Sleep -Seconds 1
              $vm = Get-VM -Name $VmName
            } while ($vm.State -ne 'Off')
          }

          # 8. Quitar todos los DVD drives
          Get-VMDvdDrive -VMName $VmName -ErrorAction SilentlyContinue |
            ForEach-Object {
              Remove-VMDvdDrive -VMName $VmName `
                                -ControllerNumber $_.ControllerNumber `
                                -ControllerLocation $_.ControllerLocation `
                                -Confirm:$false
            }

          # 9. Agregar DVD de Rocky en SCSI 0:0 y Kickstart (OEMDRV) en 0:1
          $dvdMain = Add-VMDvdDrive -VMName $VmName `
                                    -ControllerNumber 0 `
                                    -ControllerLocation 0 `
                                    -Path $IsoPath

          $dvdKs = Add-VMDvdDrive -VMName $VmName `
                                   -ControllerNumber 0 `
                                   -ControllerLocation 1 `
                                   -Path $KsIsoPath

          # 10. Forzar arranque UEFI desde la ISO de Rocky, SecureBoot OFF
          $dvd = Get-VMDvdDrive -VMName $VmName | Where-Object { $_.Path -eq $IsoPath }

          Set-VMFirmware -VMName $VmName `
            -EnableSecureBoot Off `
            -FirstBootDevice $dvd

          Write-Host "Boot UEFI forzado desde DVD principal de Rocky (SecureBoot OFF)."

          # 11. Iniciar VM
          $vm = Get-VM -Name $VmName
          if ($vm.State -ne 'Running') {
            Start-VM -Name $VmName | Out-Null
            Write-Host "VM iniciada: $VmName"
          } else {
            Write-Host "VM ya estaba corriendo."
          }

        parameters:
          VmName: "{{ vm_name }}"
          MemoryBytes: "{{ memory_bytes }}"
          DiskBytes: "{{ disk_bytes }}"
          CpuCount: "{{ cpu_count }}"
          SwitchName: "{{ v_switch_eff }}"
          IsoPath: "{{ iso_path_eff }}"
          KsIsoPath: "{{ ks_iso_path }}"
          CandidateDrives: "{{ candidate_drives }}"
          VlanId: "{{ vm_vlan | default('0') | int }}"

    # -------------------------------------------------------------------
    # 5) Mensaje final
    # -------------------------------------------------------------------
    - name: Resumen de la creación
      ansible.builtin.debug:
        msg:
          - "============================================"
          - "VM creada exitosamente: {{ vm_name }}"
          - "Host Hyper-V: {{ inventory_hostname }}"
          - "Memoria: {{ memory_gb }} GB (estática)"
          - "CPU: {{ cpu_count }} cores"
          - "Disco: {{ disk_gb }} GB"
          - "IP: {{ vm_ip }}/{{ vm_mask }}"
          - "Gateway: {{ vm_gateway }}"
          - "DNS: {{ vm_dns1 }}, {{ vm_dns2_eff }}"
          - "vSwitch: {{ v_switch_eff }}"
          - "ISO Rocky: {{ iso_path_eff }}"
          - "ISO Kickstart: {{ ks_iso_path }}"
          - "============================================"
          - "La VM está arrancando con instalación automática"
          - "La instalación de Rocky Linux tomará varios minutos"
          - "============================================"
