---
- name: Crear VM en Hyper-V (cascarón + disco + ISO desde ruta compartida con autenticación)
  hosts: localhost
  gather_facts: no

  vars:
    # Hosts válidos donde se permite crear VMs
    hyperv_hosts:
      - SMXFCFVB
      - SMXHVCEDIS
      - SMXHVFCAWS19
      - SMXHVFCBWS19
      - SMXHYPVA

    # vSwitch por defecto (si no se manda v_switch)
    default_switch: 'LAN-Prod'

    # Unidades que pueden contener las VMs (el script elegirá la que tenga más espacio)
    candidate_drives:
      - 'D'
      - 'E'

    # ISO por defecto
    iso_path_default: '\\10.138.120.15\isos\SERVER_EVAL_x64FRE_es-es.iso'

    # >>>>>>>>>>>>>>> VARIABLES DE AUTENTICACIÓN PARA ISO (MANDATORIAS) <<<<<<<<<<<<<<<
    # Debes definir estas variables al ejecutar Ansible (ej. --extra-vars "iso_user=usuario iso_password=secreto")
    # iso_user: 'dominio\usuario_con_acceso_a_isos'
    # iso_password: 'tu_contraseña_segura'
    # Drive temporal a usar para mapear el recurso compartido (debe ser una letra libre)
    iso_drive_letter: 'Z'


  collections:
    - ansible.windows

  tasks:

    #################################################################
    # VALIDACIÓN Y PREPARACIÓN
    #################################################################

    - name: Validar variables obligatorias, incluyendo credenciales de ISO
      ansible.builtin.assert:
        that:
          - hyperv_host is defined
          - vm_name is defined
          - memory_gb is defined
          - cpu is defined
          - disk_gb is defined
          - iso_user is defined
          - iso_password is defined
          - hyperv_host | length > 0
          - vm_name | length > 0
          - iso_user | length > 0
        fail_msg: "Faltan variables obligatorias: hyperv_host, vm_name, memory_gb, cpu, disk_gb, iso_user, iso_password."

    - name: Validar que el host elegido está en la lista permitida
      ansible.builtin.assert:
        that:
          - hyperv_host in hyperv_hosts
        fail_msg: "El host {{ hyperv_host }} no está en la lista de hyperv_hosts permitidos."

    - name: Normalizar variables y defaults
      ansible.builtin.set_fact:
        v_switch_eff: "{{ v_switch | default(default_switch) }}"
        iso_path_eff: "{{ iso_path | default(iso_path_default) }}"
        memory_bytes: "{{ (memory_gb | int) * 1073741824 }}"
        disk_bytes: "{{ (disk_gb | int) * 1073741824 }}"
        cpu_count: "{{ cpu | int }}"

    - name: Debug de variables
      ansible.builtin.debug:
        msg:
          hyperv_host: "{{ hyperv_host }}"
          vm_name: "{{ vm_name }}"
          iso_path: "{{ iso_path_eff }}"
          iso_user: "{{ iso_user }}"
          iso_drive_letter: "{{ iso_drive_letter }}"

    #################################################################
    # CREACIÓN DE VM EN HYPER-V (PowerShell)
    #################################################################

    - name: Crear VM en Hyper-V (estructura, VHDX y ISO)
      ansible.windows.win_powershell:
        script: |
          param(
            [string]$VmName,
            [Int64]$MemoryBytes,
            [Int64]$DiskBytes,
            [int]$CpuCount,
            [string]$SwitchName,
            [string]$IsoPath,
            [string[]]$CandidateDrives,
            [string]$IsoUser,
            [string]$IsoPassword,
            [string]$IsoDriveLetter
          )

          Import-Module Hyper-V

          # Usamos un bloque try/finally para garantizar que la unidad mapeada se limpie
          try {

              # =================================================================
              # 1. AUTENTICACIÓN Y MONTAJE TEMPORAL DE ISO
              # =================================================================
              $OriginalIsoPath = $IsoPath
              
              if ($IsoPath -and $IsoUser -and $IsoPassword) {
                  Write-Host "Intentando autenticar y mapear el recurso compartido de la ISO..."

                  # Crear objeto de credenciales
                  $secPass = ConvertTo-SecureString -String $IsoPassword -AsPlainText -Force
                  $credential = New-Object System.Management.Automation.PSCredential($IsoUser, $secPass)

                  # Separar la ruta UNC del nombre del archivo
                  $isoFileName = Split-Path -Path $IsoPath -Leaf
                  $isoUncRoot = Split-Path -Path $IsoPath -Parent

                  try {
                      # Crear una unidad de red temporal (ej: Z:).
                      New-PSDrive -Name $IsoDriveLetter -PSProvider FileSystem -Root $isoUncRoot -Credential $credential -Persist -ErrorAction Stop | Out-Null
                      
                      # Sobrescribir $IsoPath para usar la ruta de la unidad mapeada
                      $IsoPath = Join-Path "$($IsoDriveLetter):" $isoFileName
                      Write-Host "ISO Path actualizado a la unidad mapeada ($($IsoDriveLetter)): $IsoPath"

                  } catch {
                      Write-Host "ERROR: Falló el mapeo de la unidad temporal '$($IsoDriveLetter):' con las credenciales."
                      Write-Host ("Detalle: {0}" -f $_.Exception.Message)
                      $IsoPath = $OriginalIsoPath
                  }
              }
              
              # =================================================================
              # 2. SELECCIÓN DE UNIDAD Y CREACIÓN DE CARPETAS
              # =================================================================

              # Elegir la unidad con más espacio libre (D o E)
              $drives = foreach ($d in $CandidateDrives) {
                try {
                  Get-PSDrive -Name $d -ErrorAction Stop
                } catch {
                  $null
                }
              }

              if (-not $drives) {
                throw "Ninguna de las unidades candidatas ($($CandidateDrives -join ', ')) existe en este host."
              }

              $bestDrive = $drives | Sort-Object Free -Descending | Select-Object -First 1
              Write-Host "Usando unidad $($bestDrive.Name): libre $([math]::Round($bestDrive.Free / 1GB, 2)) GB"

              # Estructura de carpetas
              $root      = $bestDrive.Root
              $clusterRoot = Join-Path $root $VmName
              $vhdRoot       = Join-Path $clusterRoot "Virtual Hard Disks"
              $VmPath = $clusterRoot
              $VhdPath = Join-Path $vhdRoot ("{0}.vhdx" -f $VmName) 

              foreach ($p in @($clusterRoot, $vhdRoot)) {
                if (-not (Test-Path $p)) {
                  New-Item -ItemType Directory -Path $p -Force | Out-Null
                }
              }

              # =================================================================
              # 3. CREACIÓN Y CONFIGURACIÓN DE LA VM
              # =================================================================

              # Validar acceso a la ISO (usando la ruta mapeada/actualizada)
              $isoOk = $false
              if ($IsoPath -and $IsoPath.Trim() -ne '') {
                try {
                  $isoOk = Test-Path $IsoPath -ErrorAction Stop
                  Write-Host "ISO accesible: $IsoPath (Test-Path = $isoOk)"
                } catch {
                  Write-Host "ADVERTENCIA: No se pudo acceder a la ISO: $IsoPath. Detalle: $($_.Exception.Message)"
                  $isoOk = $false
                }
              }

              if (-not $isoOk) {
                Write-Host "Continuando sin montar ISO en la VM."
                $IsoPath = $null
              }

              # Crear VHDX vacío
              if (-not (Test-Path $VhdPath)) {
                New-VHD -Path $VhdPath -SizeBytes $DiskBytes -Dynamic | Out-Null
              }

              # Crear VM si no existe
              if (-not (Get-VM -Name $VmName -ErrorAction SilentlyContinue)) {
                # Comando en una sola línea para evitar errores de parser
                New-VM -Name $VmName -MemoryStartupBytes $MemoryBytes -Generation 2 -VHDPath $VhdPath -SwitchName $SwitchName -Path $VmPath | Out-Null
              } else {
                Write-Host "La VM $VmName ya existe, no se vuelve a crear."
              }

              # Configurar VM
              Set-VMProcessor -VMName $VmName -Count $CpuCount
              Set-VMMemory -VMName $VmName -DynamicMemoryEnabled $true -MinimumBytes 1GB -MaximumBytes ($MemoryBytes * 2) # Comando en una sola línea
              
              # Montar ISO
              if ($IsoPath) {
                try {
                  Set-VMDvdDrive -VMName $VmName -Path $IsoPath -ErrorAction Stop
                  $dvd = Get-VMDvdDrive -VMName $VmName
                  Set-VMFirmware -VMName $VmName -FirstBootDevice $dvd
                  Write-Host "ISO montada exitosamente y puesta como primer dispositivo de arranque."
                } catch {
                  Write-Host ("ADVERTENCIA: Error al montar la ISO en la VM {0}: {1}" -f $VmName, $_.Exception.Message)
                }
              }
              
              # Iniciar VM
              Start-VM -Name $VmName

          } finally {
              # =================================================================
              # 4. LIMPIEZA
              # =================================================================
              # Usamos Remove-PSDrive y silenciamos toda salida para evitar el error de JSON del parser de Ansible.
              if ($IsoDriveLetter -and (Get-PSDrive -Name $IsoDriveLetter -ErrorAction SilentlyContinue)) {
                  Write-Host "Limpiando unidad mapeada temporal ($($IsoDriveLetter):)."
                  Remove-PSDrive -Name $IsoDriveLetter -Force | Out-Null
                  Write-Host "Limpieza completada."
              }
          }


        parameters:
          VmName: "{{ vm_name }}"
          MemoryBytes: "{{ memory_bytes }}"
          DiskBytes: "{{ disk_bytes }}"
          CpuCount: "{{ cpu_count }}"
          SwitchName: "{{ v_switch_eff }}"
          IsoPath: "{{ iso_path_eff }}"
          CandidateDrives: "{{ candidate_drives }}"
          # Credenciales
          IsoUser: "{{ iso_user }}"
          IsoPassword: "{{ iso_password }}"
          IsoDriveLetter: "{{ iso_drive_letter }}"
        delegate_to: "{{ hyperv_host }}"
        run_once: true
